resource: https://ir0nstone.gitbook.io/notes/types/stack/introduction

```
$ r2 -d -A vuln
```

The `-d` runs it while the `-A` performs analysis. We can disassemble `main` with

```
s main; pdf
```

`s main` seeks (moves) to main, while `pdf` stands for **P**rint **D**isassembly **F**unction (literally just disassembles it).
The call to `unsafe` is at `0x080491bb`, so let's break there.

```
db 0x080491bb
```

`db` stands for **d**ebug **b**reakpoint, and just sets a breakpoint. A breakpoint is simply somewhere which, when reached, pauses the program for you to run other commands. Now we run `dc` for **d**ebug **c**ontinue; this just carries on running the file.

```
[0x08049172]> pxw @ esp
0xff984af0 0xf7efe000         [...]
```

`pxw` tells r2 to analyse the hex as **words**, that is, 32-bit values. I only show the first value here, which is `0xf7efe000`. This value is stored at the top of the stack, as ESP points to the top of the stack - in this case, that is `0xff984af0`.

Let's move one more instruction with `ds`, **d**ebug **s**tep, and check the stack again. This will execute the `call sym.unsafe` instruction.

We can see that `0x080491c0` is the memory address of the instruction _after_ the call to `unsafe`. Why? This is how the program knows _where to return to after_ `_unsafe()_` _has finished_.

`ret` is the equivalent of `pop eip`, which will get the saved return pointer we just analysed on the stack into the `eip` register.

